####################################

from fenics import *
from mshr import*
import numpy as np
import sys
#Add the path to Dymms module to the code
sys.path.insert(0, '../../modules/')
from mupopp import *

from scipy.interpolate import griddata
####################################
# Read the nondimensional numbers from
# the .cfg file and
# Initiate the system
####################################

param_file = sys.argv[1]
sphere=compaction(param_file)

####################################
# Output files
####################################
output_dir     = "output/"
extension      = "pvd"   # "xdmf" or "pvd"
initial_porosity_out = File(output_dir + "initial_porosity." + extension,\
                            "compressed")
velocity_out   = File(output_dir + "velocity." + extension, "compressed")
pressure_out   = File(output_dir + "pressure." + extension, "compressed")
porosity_out   = File(output_dir + "porosity." + extension, "compressed")
compact_out   = File(output_dir + "compaction." + extension, "compressed")
gam_out   = File(output_dir + "gamma." + extension, "compressed")

####################################

####################################
# import 3d soliton from Gideon Simpson's code
# (two columns in "input.out" file)
# define origin (max porosity location)
# input.out contains 2 columns of numbers
###################################
def calculateDistance(x1,y1,z1,x2,y2,z2):
    dist = np.sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2)
    return dist
class Source(Expression):
    def eval(self, values, x):
        #distance from defined origin
        r0 = calculateDistance(x[0],x[1],x[2],x0,y0,z0)
        values[0] = griddata(R_sol, Phi_sol, r0, method = 'linear')

data = np.loadtxt("input.out")                       
R_sol,Phi_sol = 0.04183300132 * data[:,0], 0.1 * data[:,1]
# data is 1D numpy array
x0 = 0.0;
y0 = 0.0;
z0 = -2.0; #Change this value to recenter the soliton vertically

#####################################
# Generate the meshy
#####################################
Lx     =  4.0
Ly     =  4.0
Lz     =  8.0
x0_min = -Lx/2
x0_max =  Lx/2
x1_min = -Ly/2
x1_max =  Ly/2
x2_min = -Lz/2
x2_max =  Lz/2
n0     =  64
n1     =  64
n2     =  64

p1 = Point(x0_min, x1_min, x2_min)
p2 = Point(x0_max, x1_max, x2_max)

mesh = BoxMesh(p1, p2, n0, n1, n2)
#
# Sub domain for Periodic boundary condition
class PeriodicBoundary(SubDomain):
    
    # Bottom boundary is "target domain" G
    def inside(self, x, on_boundary):
        return bool( near(x[2], -Lz/2.) and on_boundary)
    
    # Map Top boundary (H) to Bottom boundary (G)
    def map(self, x, y):
        if near(x[2], Lz/2):
            y[0] = x[0]
            y[1] = x[1]
            y[2] = x[2] - Lz
        else:
            y[0] = -1000
            y[1] = -1000
            y[2] = -1000



# Create periodic boundary condition
pbc = PeriodicBoundary()

##################################
# Create Function spaces
#################################
# Velocity
V     = VectorElement("Lagrange", mesh.ufl_cell(), 2)
# Pressure
Q     = FiniteElement("Lagrange", mesh.ufl_cell(), 1)
#Compaction
OMEGA = FiniteElement("Lagrange", mesh.ufl_cell(), 1)
# Make a mixed space
W     = dolfin.FunctionSpace(mesh, MixedElement([V,Q,OMEGA]), constrained_domain=pbc)
# Output fuction space
# Porosity
X     = FunctionSpace(mesh, "CG", 2, constrained_domain=pbc)
# Velocity
Y     = VectorFunctionSpace(mesh,"CG",2, constrained_domain=pbc)
